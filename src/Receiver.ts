import AbstractPeer from "@/src/abstracts/AbstractPeer";

class Receiver extends AbstractPeer {

    /**
     * The SDP offer generated by the initiator. This string is received from the remote peer.
     * @private
     * @type {string}
     */
    private offerString: string = ''; // Do not use "!offerString"
    private RTCOffer: RTCSessionDescription | null = null; // @todo Still in BETA

    /**
     * The constructor: sets up the peer connection and event handlers.
     * @param RTCConfiguration RTCConfiguration|object
     */
    constructor(RTCConfiguration?: RTCConfiguration) {
        super(RTCConfiguration ?? {
            iceServers: [
                {
                    urls: 'stun:stun.l.google.com:19302'
                }
            ]
        });

        // Set the data channel as soon as it is created
        this.getPeerConnection().ondatachannel = (event) => {
            this.getPeerConnection().setDataChannel( event.channel );
        };
    }

    /**
     * Processes the Offer and generates an Answer.
     * @param offerString string
     * @returns {Promise<void>}
     */
    public async processOffer(offerString: string): Promise<void> {

        this.offerString = offerString;

        return this.processSignalingData(offerString).then(async (results) => {
            for (const data of results) {
                /**
                 * The peer connection "remote description" bust be set before processing ICE candidates;
                 * usually, the first line of the offer string is the SDP offer, thus, the "remote description"
                 * is set first. After that, the ICE candidates are processed. Failing to set the remote
                 * description first will probably cause the ICE candidates to be ignored.
                 */
                if (data.type === 'sdp') {
                    // Set the remote SDP description (the peer's offer)
                    await this.getPeerConnection().setRemoteDescription( new RTCSessionDescription(data.sdp) );

                    const answer = await this.getPeerConnection().createAnswer();
                    await this.getPeerConnection().setLocalDescription(answer);

                    // Add the SDP Answer to the Answer string
                    this.appendSignalingData({ type: 'sdp', sdp: this.getPeerConnection().localDescription });
                }

                // Process ICE candidates
                if (data.type === 'ice' && data.candidate) {
                    await this.getPeerConnection().addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            }
        });
    }

    /**
     * Returns the received offer.
     * @returns {string}
     */
    public getOffer(): string {
        return this.offerString;
    }

    /**
     * Returns the generated answer.
     * @returns {string}
     */
    public getAnswer(): string {
        return this.getSignalingString();
    }
}

export default Receiver;